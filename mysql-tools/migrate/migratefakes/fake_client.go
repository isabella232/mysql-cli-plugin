// Code generated by counterfeiter. DO NOT EDIT.
package migratefakes

import (
	"sync"

	"github.com/pivotal-cf/mysql-cli-plugin/mysql-tools/migrate"
)

type FakeClient struct {
	ServiceExistsStub        func(serviceName string) bool
	serviceExistsMutex       sync.RWMutex
	serviceExistsArgsForCall []struct {
		serviceName string
	}
	serviceExistsReturns struct {
		result1 bool
	}
	serviceExistsReturnsOnCall map[int]struct {
		result1 bool
	}
	CreateServiceInstanceStub        func(planType, instanceName string) error
	createServiceInstanceMutex       sync.RWMutex
	createServiceInstanceArgsForCall []struct {
		planType     string
		instanceName string
	}
	createServiceInstanceReturns struct {
		result1 error
	}
	createServiceInstanceReturnsOnCall map[int]struct {
		result1 error
	}
	GetHostnamesStub        func(instanceName string) ([]string, error)
	getHostnamesMutex       sync.RWMutex
	getHostnamesArgsForCall []struct {
		instanceName string
	}
	getHostnamesReturns struct {
		result1 []string
		result2 error
	}
	getHostnamesReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	UpdateServiceConfigStub        func(instanceName string, jsonParams string) error
	updateServiceConfigMutex       sync.RWMutex
	updateServiceConfigArgsForCall []struct {
		instanceName string
		jsonParams   string
	}
	updateServiceConfigReturns struct {
		result1 error
	}
	updateServiceConfigReturnsOnCall map[int]struct {
		result1 error
	}
	BindServiceStub        func(appName, serviceName string) error
	bindServiceMutex       sync.RWMutex
	bindServiceArgsForCall []struct {
		appName     string
		serviceName string
	}
	bindServiceReturns struct {
		result1 error
	}
	bindServiceReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteAppStub        func(appName string) error
	deleteAppMutex       sync.RWMutex
	deleteAppArgsForCall []struct {
		appName string
	}
	deleteAppReturns struct {
		result1 error
	}
	deleteAppReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteServiceInstanceStub        func(instanceName string) error
	deleteServiceInstanceMutex       sync.RWMutex
	deleteServiceInstanceArgsForCall []struct {
		instanceName string
	}
	deleteServiceInstanceReturns struct {
		result1 error
	}
	deleteServiceInstanceReturnsOnCall map[int]struct {
		result1 error
	}
	DumpLogsStub        func(appName string)
	dumpLogsMutex       sync.RWMutex
	dumpLogsArgsForCall []struct {
		appName string
	}
	PushAppStub        func(path, appName string) error
	pushAppMutex       sync.RWMutex
	pushAppArgsForCall []struct {
		path    string
		appName string
	}
	pushAppReturns struct {
		result1 error
	}
	pushAppReturnsOnCall map[int]struct {
		result1 error
	}
	RenameServiceStub        func(oldName, newName string) error
	renameServiceMutex       sync.RWMutex
	renameServiceArgsForCall []struct {
		oldName string
		newName string
	}
	renameServiceReturns struct {
		result1 error
	}
	renameServiceReturnsOnCall map[int]struct {
		result1 error
	}
	RunTaskStub        func(appName, command string) error
	runTaskMutex       sync.RWMutex
	runTaskArgsForCall []struct {
		appName string
		command string
	}
	runTaskReturns struct {
		result1 error
	}
	runTaskReturnsOnCall map[int]struct {
		result1 error
	}
	StartAppStub        func(appName string) error
	startAppMutex       sync.RWMutex
	startAppArgsForCall []struct {
		appName string
	}
	startAppReturns struct {
		result1 error
	}
	startAppReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClient) ServiceExists(serviceName string) bool {
	fake.serviceExistsMutex.Lock()
	ret, specificReturn := fake.serviceExistsReturnsOnCall[len(fake.serviceExistsArgsForCall)]
	fake.serviceExistsArgsForCall = append(fake.serviceExistsArgsForCall, struct {
		serviceName string
	}{serviceName})
	fake.recordInvocation("ServiceExists", []interface{}{serviceName})
	fake.serviceExistsMutex.Unlock()
	if fake.ServiceExistsStub != nil {
		return fake.ServiceExistsStub(serviceName)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.serviceExistsReturns.result1
}

func (fake *FakeClient) ServiceExistsCallCount() int {
	fake.serviceExistsMutex.RLock()
	defer fake.serviceExistsMutex.RUnlock()
	return len(fake.serviceExistsArgsForCall)
}

func (fake *FakeClient) ServiceExistsArgsForCall(i int) string {
	fake.serviceExistsMutex.RLock()
	defer fake.serviceExistsMutex.RUnlock()
	return fake.serviceExistsArgsForCall[i].serviceName
}

func (fake *FakeClient) ServiceExistsReturns(result1 bool) {
	fake.ServiceExistsStub = nil
	fake.serviceExistsReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeClient) ServiceExistsReturnsOnCall(i int, result1 bool) {
	fake.ServiceExistsStub = nil
	if fake.serviceExistsReturnsOnCall == nil {
		fake.serviceExistsReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.serviceExistsReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeClient) CreateServiceInstance(planType string, instanceName string) error {
	fake.createServiceInstanceMutex.Lock()
	ret, specificReturn := fake.createServiceInstanceReturnsOnCall[len(fake.createServiceInstanceArgsForCall)]
	fake.createServiceInstanceArgsForCall = append(fake.createServiceInstanceArgsForCall, struct {
		planType     string
		instanceName string
	}{planType, instanceName})
	fake.recordInvocation("CreateServiceInstance", []interface{}{planType, instanceName})
	fake.createServiceInstanceMutex.Unlock()
	if fake.CreateServiceInstanceStub != nil {
		return fake.CreateServiceInstanceStub(planType, instanceName)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.createServiceInstanceReturns.result1
}

func (fake *FakeClient) CreateServiceInstanceCallCount() int {
	fake.createServiceInstanceMutex.RLock()
	defer fake.createServiceInstanceMutex.RUnlock()
	return len(fake.createServiceInstanceArgsForCall)
}

func (fake *FakeClient) CreateServiceInstanceArgsForCall(i int) (string, string) {
	fake.createServiceInstanceMutex.RLock()
	defer fake.createServiceInstanceMutex.RUnlock()
	return fake.createServiceInstanceArgsForCall[i].planType, fake.createServiceInstanceArgsForCall[i].instanceName
}

func (fake *FakeClient) CreateServiceInstanceReturns(result1 error) {
	fake.CreateServiceInstanceStub = nil
	fake.createServiceInstanceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) CreateServiceInstanceReturnsOnCall(i int, result1 error) {
	fake.CreateServiceInstanceStub = nil
	if fake.createServiceInstanceReturnsOnCall == nil {
		fake.createServiceInstanceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createServiceInstanceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) GetHostnames(instanceName string) ([]string, error) {
	fake.getHostnamesMutex.Lock()
	ret, specificReturn := fake.getHostnamesReturnsOnCall[len(fake.getHostnamesArgsForCall)]
	fake.getHostnamesArgsForCall = append(fake.getHostnamesArgsForCall, struct {
		instanceName string
	}{instanceName})
	fake.recordInvocation("GetHostnames", []interface{}{instanceName})
	fake.getHostnamesMutex.Unlock()
	if fake.GetHostnamesStub != nil {
		return fake.GetHostnamesStub(instanceName)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getHostnamesReturns.result1, fake.getHostnamesReturns.result2
}

func (fake *FakeClient) GetHostnamesCallCount() int {
	fake.getHostnamesMutex.RLock()
	defer fake.getHostnamesMutex.RUnlock()
	return len(fake.getHostnamesArgsForCall)
}

func (fake *FakeClient) GetHostnamesArgsForCall(i int) string {
	fake.getHostnamesMutex.RLock()
	defer fake.getHostnamesMutex.RUnlock()
	return fake.getHostnamesArgsForCall[i].instanceName
}

func (fake *FakeClient) GetHostnamesReturns(result1 []string, result2 error) {
	fake.GetHostnamesStub = nil
	fake.getHostnamesReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetHostnamesReturnsOnCall(i int, result1 []string, result2 error) {
	fake.GetHostnamesStub = nil
	if fake.getHostnamesReturnsOnCall == nil {
		fake.getHostnamesReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.getHostnamesReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpdateServiceConfig(instanceName string, jsonParams string) error {
	fake.updateServiceConfigMutex.Lock()
	ret, specificReturn := fake.updateServiceConfigReturnsOnCall[len(fake.updateServiceConfigArgsForCall)]
	fake.updateServiceConfigArgsForCall = append(fake.updateServiceConfigArgsForCall, struct {
		instanceName string
		jsonParams   string
	}{instanceName, jsonParams})
	fake.recordInvocation("UpdateServiceConfig", []interface{}{instanceName, jsonParams})
	fake.updateServiceConfigMutex.Unlock()
	if fake.UpdateServiceConfigStub != nil {
		return fake.UpdateServiceConfigStub(instanceName, jsonParams)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.updateServiceConfigReturns.result1
}

func (fake *FakeClient) UpdateServiceConfigCallCount() int {
	fake.updateServiceConfigMutex.RLock()
	defer fake.updateServiceConfigMutex.RUnlock()
	return len(fake.updateServiceConfigArgsForCall)
}

func (fake *FakeClient) UpdateServiceConfigArgsForCall(i int) (string, string) {
	fake.updateServiceConfigMutex.RLock()
	defer fake.updateServiceConfigMutex.RUnlock()
	return fake.updateServiceConfigArgsForCall[i].instanceName, fake.updateServiceConfigArgsForCall[i].jsonParams
}

func (fake *FakeClient) UpdateServiceConfigReturns(result1 error) {
	fake.UpdateServiceConfigStub = nil
	fake.updateServiceConfigReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) UpdateServiceConfigReturnsOnCall(i int, result1 error) {
	fake.UpdateServiceConfigStub = nil
	if fake.updateServiceConfigReturnsOnCall == nil {
		fake.updateServiceConfigReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateServiceConfigReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) BindService(appName string, serviceName string) error {
	fake.bindServiceMutex.Lock()
	ret, specificReturn := fake.bindServiceReturnsOnCall[len(fake.bindServiceArgsForCall)]
	fake.bindServiceArgsForCall = append(fake.bindServiceArgsForCall, struct {
		appName     string
		serviceName string
	}{appName, serviceName})
	fake.recordInvocation("BindService", []interface{}{appName, serviceName})
	fake.bindServiceMutex.Unlock()
	if fake.BindServiceStub != nil {
		return fake.BindServiceStub(appName, serviceName)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.bindServiceReturns.result1
}

func (fake *FakeClient) BindServiceCallCount() int {
	fake.bindServiceMutex.RLock()
	defer fake.bindServiceMutex.RUnlock()
	return len(fake.bindServiceArgsForCall)
}

func (fake *FakeClient) BindServiceArgsForCall(i int) (string, string) {
	fake.bindServiceMutex.RLock()
	defer fake.bindServiceMutex.RUnlock()
	return fake.bindServiceArgsForCall[i].appName, fake.bindServiceArgsForCall[i].serviceName
}

func (fake *FakeClient) BindServiceReturns(result1 error) {
	fake.BindServiceStub = nil
	fake.bindServiceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) BindServiceReturnsOnCall(i int, result1 error) {
	fake.BindServiceStub = nil
	if fake.bindServiceReturnsOnCall == nil {
		fake.bindServiceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.bindServiceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeleteApp(appName string) error {
	fake.deleteAppMutex.Lock()
	ret, specificReturn := fake.deleteAppReturnsOnCall[len(fake.deleteAppArgsForCall)]
	fake.deleteAppArgsForCall = append(fake.deleteAppArgsForCall, struct {
		appName string
	}{appName})
	fake.recordInvocation("DeleteApp", []interface{}{appName})
	fake.deleteAppMutex.Unlock()
	if fake.DeleteAppStub != nil {
		return fake.DeleteAppStub(appName)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteAppReturns.result1
}

func (fake *FakeClient) DeleteAppCallCount() int {
	fake.deleteAppMutex.RLock()
	defer fake.deleteAppMutex.RUnlock()
	return len(fake.deleteAppArgsForCall)
}

func (fake *FakeClient) DeleteAppArgsForCall(i int) string {
	fake.deleteAppMutex.RLock()
	defer fake.deleteAppMutex.RUnlock()
	return fake.deleteAppArgsForCall[i].appName
}

func (fake *FakeClient) DeleteAppReturns(result1 error) {
	fake.DeleteAppStub = nil
	fake.deleteAppReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeleteAppReturnsOnCall(i int, result1 error) {
	fake.DeleteAppStub = nil
	if fake.deleteAppReturnsOnCall == nil {
		fake.deleteAppReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteAppReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeleteServiceInstance(instanceName string) error {
	fake.deleteServiceInstanceMutex.Lock()
	ret, specificReturn := fake.deleteServiceInstanceReturnsOnCall[len(fake.deleteServiceInstanceArgsForCall)]
	fake.deleteServiceInstanceArgsForCall = append(fake.deleteServiceInstanceArgsForCall, struct {
		instanceName string
	}{instanceName})
	fake.recordInvocation("DeleteServiceInstance", []interface{}{instanceName})
	fake.deleteServiceInstanceMutex.Unlock()
	if fake.DeleteServiceInstanceStub != nil {
		return fake.DeleteServiceInstanceStub(instanceName)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteServiceInstanceReturns.result1
}

func (fake *FakeClient) DeleteServiceInstanceCallCount() int {
	fake.deleteServiceInstanceMutex.RLock()
	defer fake.deleteServiceInstanceMutex.RUnlock()
	return len(fake.deleteServiceInstanceArgsForCall)
}

func (fake *FakeClient) DeleteServiceInstanceArgsForCall(i int) string {
	fake.deleteServiceInstanceMutex.RLock()
	defer fake.deleteServiceInstanceMutex.RUnlock()
	return fake.deleteServiceInstanceArgsForCall[i].instanceName
}

func (fake *FakeClient) DeleteServiceInstanceReturns(result1 error) {
	fake.DeleteServiceInstanceStub = nil
	fake.deleteServiceInstanceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeleteServiceInstanceReturnsOnCall(i int, result1 error) {
	fake.DeleteServiceInstanceStub = nil
	if fake.deleteServiceInstanceReturnsOnCall == nil {
		fake.deleteServiceInstanceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteServiceInstanceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DumpLogs(appName string) {
	fake.dumpLogsMutex.Lock()
	fake.dumpLogsArgsForCall = append(fake.dumpLogsArgsForCall, struct {
		appName string
	}{appName})
	fake.recordInvocation("DumpLogs", []interface{}{appName})
	fake.dumpLogsMutex.Unlock()
	if fake.DumpLogsStub != nil {
		fake.DumpLogsStub(appName)
	}
}

func (fake *FakeClient) DumpLogsCallCount() int {
	fake.dumpLogsMutex.RLock()
	defer fake.dumpLogsMutex.RUnlock()
	return len(fake.dumpLogsArgsForCall)
}

func (fake *FakeClient) DumpLogsArgsForCall(i int) string {
	fake.dumpLogsMutex.RLock()
	defer fake.dumpLogsMutex.RUnlock()
	return fake.dumpLogsArgsForCall[i].appName
}

func (fake *FakeClient) PushApp(path string, appName string) error {
	fake.pushAppMutex.Lock()
	ret, specificReturn := fake.pushAppReturnsOnCall[len(fake.pushAppArgsForCall)]
	fake.pushAppArgsForCall = append(fake.pushAppArgsForCall, struct {
		path    string
		appName string
	}{path, appName})
	fake.recordInvocation("PushApp", []interface{}{path, appName})
	fake.pushAppMutex.Unlock()
	if fake.PushAppStub != nil {
		return fake.PushAppStub(path, appName)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.pushAppReturns.result1
}

func (fake *FakeClient) PushAppCallCount() int {
	fake.pushAppMutex.RLock()
	defer fake.pushAppMutex.RUnlock()
	return len(fake.pushAppArgsForCall)
}

func (fake *FakeClient) PushAppArgsForCall(i int) (string, string) {
	fake.pushAppMutex.RLock()
	defer fake.pushAppMutex.RUnlock()
	return fake.pushAppArgsForCall[i].path, fake.pushAppArgsForCall[i].appName
}

func (fake *FakeClient) PushAppReturns(result1 error) {
	fake.PushAppStub = nil
	fake.pushAppReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PushAppReturnsOnCall(i int, result1 error) {
	fake.PushAppStub = nil
	if fake.pushAppReturnsOnCall == nil {
		fake.pushAppReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pushAppReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) RenameService(oldName string, newName string) error {
	fake.renameServiceMutex.Lock()
	ret, specificReturn := fake.renameServiceReturnsOnCall[len(fake.renameServiceArgsForCall)]
	fake.renameServiceArgsForCall = append(fake.renameServiceArgsForCall, struct {
		oldName string
		newName string
	}{oldName, newName})
	fake.recordInvocation("RenameService", []interface{}{oldName, newName})
	fake.renameServiceMutex.Unlock()
	if fake.RenameServiceStub != nil {
		return fake.RenameServiceStub(oldName, newName)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.renameServiceReturns.result1
}

func (fake *FakeClient) RenameServiceCallCount() int {
	fake.renameServiceMutex.RLock()
	defer fake.renameServiceMutex.RUnlock()
	return len(fake.renameServiceArgsForCall)
}

func (fake *FakeClient) RenameServiceArgsForCall(i int) (string, string) {
	fake.renameServiceMutex.RLock()
	defer fake.renameServiceMutex.RUnlock()
	return fake.renameServiceArgsForCall[i].oldName, fake.renameServiceArgsForCall[i].newName
}

func (fake *FakeClient) RenameServiceReturns(result1 error) {
	fake.RenameServiceStub = nil
	fake.renameServiceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) RenameServiceReturnsOnCall(i int, result1 error) {
	fake.RenameServiceStub = nil
	if fake.renameServiceReturnsOnCall == nil {
		fake.renameServiceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renameServiceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) RunTask(appName string, command string) error {
	fake.runTaskMutex.Lock()
	ret, specificReturn := fake.runTaskReturnsOnCall[len(fake.runTaskArgsForCall)]
	fake.runTaskArgsForCall = append(fake.runTaskArgsForCall, struct {
		appName string
		command string
	}{appName, command})
	fake.recordInvocation("RunTask", []interface{}{appName, command})
	fake.runTaskMutex.Unlock()
	if fake.RunTaskStub != nil {
		return fake.RunTaskStub(appName, command)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.runTaskReturns.result1
}

func (fake *FakeClient) RunTaskCallCount() int {
	fake.runTaskMutex.RLock()
	defer fake.runTaskMutex.RUnlock()
	return len(fake.runTaskArgsForCall)
}

func (fake *FakeClient) RunTaskArgsForCall(i int) (string, string) {
	fake.runTaskMutex.RLock()
	defer fake.runTaskMutex.RUnlock()
	return fake.runTaskArgsForCall[i].appName, fake.runTaskArgsForCall[i].command
}

func (fake *FakeClient) RunTaskReturns(result1 error) {
	fake.RunTaskStub = nil
	fake.runTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) RunTaskReturnsOnCall(i int, result1 error) {
	fake.RunTaskStub = nil
	if fake.runTaskReturnsOnCall == nil {
		fake.runTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.runTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) StartApp(appName string) error {
	fake.startAppMutex.Lock()
	ret, specificReturn := fake.startAppReturnsOnCall[len(fake.startAppArgsForCall)]
	fake.startAppArgsForCall = append(fake.startAppArgsForCall, struct {
		appName string
	}{appName})
	fake.recordInvocation("StartApp", []interface{}{appName})
	fake.startAppMutex.Unlock()
	if fake.StartAppStub != nil {
		return fake.StartAppStub(appName)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.startAppReturns.result1
}

func (fake *FakeClient) StartAppCallCount() int {
	fake.startAppMutex.RLock()
	defer fake.startAppMutex.RUnlock()
	return len(fake.startAppArgsForCall)
}

func (fake *FakeClient) StartAppArgsForCall(i int) string {
	fake.startAppMutex.RLock()
	defer fake.startAppMutex.RUnlock()
	return fake.startAppArgsForCall[i].appName
}

func (fake *FakeClient) StartAppReturns(result1 error) {
	fake.StartAppStub = nil
	fake.startAppReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) StartAppReturnsOnCall(i int, result1 error) {
	fake.StartAppStub = nil
	if fake.startAppReturnsOnCall == nil {
		fake.startAppReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.startAppReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.serviceExistsMutex.RLock()
	defer fake.serviceExistsMutex.RUnlock()
	fake.createServiceInstanceMutex.RLock()
	defer fake.createServiceInstanceMutex.RUnlock()
	fake.getHostnamesMutex.RLock()
	defer fake.getHostnamesMutex.RUnlock()
	fake.updateServiceConfigMutex.RLock()
	defer fake.updateServiceConfigMutex.RUnlock()
	fake.bindServiceMutex.RLock()
	defer fake.bindServiceMutex.RUnlock()
	fake.deleteAppMutex.RLock()
	defer fake.deleteAppMutex.RUnlock()
	fake.deleteServiceInstanceMutex.RLock()
	defer fake.deleteServiceInstanceMutex.RUnlock()
	fake.dumpLogsMutex.RLock()
	defer fake.dumpLogsMutex.RUnlock()
	fake.pushAppMutex.RLock()
	defer fake.pushAppMutex.RUnlock()
	fake.renameServiceMutex.RLock()
	defer fake.renameServiceMutex.RUnlock()
	fake.runTaskMutex.RLock()
	defer fake.runTaskMutex.RUnlock()
	fake.startAppMutex.RLock()
	defer fake.startAppMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ migrate.Client = new(FakeClient)
