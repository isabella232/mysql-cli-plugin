// Code generated by counterfeiter. DO NOT EDIT.
package pluginfakes

import (
	"sync"

	"github.com/pivotal-cf/mysql-cli-plugin/mysql-tools/plugin"
)

type FakeMigrator struct {
	CheckServiceExistsStub        func(donorInstanceName string) error
	checkServiceExistsMutex       sync.RWMutex
	checkServiceExistsArgsForCall []struct {
		donorInstanceName string
	}
	checkServiceExistsReturns struct {
		result1 error
	}
	checkServiceExistsReturnsOnCall map[int]struct {
		result1 error
	}
	CreateAndConfigureServiceInstanceStub        func(planType, serviceName string) error
	createAndConfigureServiceInstanceMutex       sync.RWMutex
	createAndConfigureServiceInstanceArgsForCall []struct {
		planType    string
		serviceName string
	}
	createAndConfigureServiceInstanceReturns struct {
		result1 error
	}
	createAndConfigureServiceInstanceReturnsOnCall map[int]struct {
		result1 error
	}
	MigrateDataStub        func(donorInstanceName, recipientInstanceName string, cleanup bool) error
	migrateDataMutex       sync.RWMutex
	migrateDataArgsForCall []struct {
		donorInstanceName     string
		recipientInstanceName string
		cleanup               bool
	}
	migrateDataReturns struct {
		result1 error
	}
	migrateDataReturnsOnCall map[int]struct {
		result1 error
	}
	RenameServiceInstancesStub        func(donorInstanceName, recipientInstanceName string) error
	renameServiceInstancesMutex       sync.RWMutex
	renameServiceInstancesArgsForCall []struct {
		donorInstanceName     string
		recipientInstanceName string
	}
	renameServiceInstancesReturns struct {
		result1 error
	}
	renameServiceInstancesReturnsOnCall map[int]struct {
		result1 error
	}
	CleanupOnErrorStub        func(recipientInstanceName string) error
	cleanupOnErrorMutex       sync.RWMutex
	cleanupOnErrorArgsForCall []struct {
		recipientInstanceName string
	}
	cleanupOnErrorReturns struct {
		result1 error
	}
	cleanupOnErrorReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeMigrator) CheckServiceExists(donorInstanceName string) error {
	fake.checkServiceExistsMutex.Lock()
	ret, specificReturn := fake.checkServiceExistsReturnsOnCall[len(fake.checkServiceExistsArgsForCall)]
	fake.checkServiceExistsArgsForCall = append(fake.checkServiceExistsArgsForCall, struct {
		donorInstanceName string
	}{donorInstanceName})
	fake.recordInvocation("CheckServiceExists", []interface{}{donorInstanceName})
	fake.checkServiceExistsMutex.Unlock()
	if fake.CheckServiceExistsStub != nil {
		return fake.CheckServiceExistsStub(donorInstanceName)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.checkServiceExistsReturns.result1
}

func (fake *FakeMigrator) CheckServiceExistsCallCount() int {
	fake.checkServiceExistsMutex.RLock()
	defer fake.checkServiceExistsMutex.RUnlock()
	return len(fake.checkServiceExistsArgsForCall)
}

func (fake *FakeMigrator) CheckServiceExistsArgsForCall(i int) string {
	fake.checkServiceExistsMutex.RLock()
	defer fake.checkServiceExistsMutex.RUnlock()
	return fake.checkServiceExistsArgsForCall[i].donorInstanceName
}

func (fake *FakeMigrator) CheckServiceExistsReturns(result1 error) {
	fake.CheckServiceExistsStub = nil
	fake.checkServiceExistsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeMigrator) CheckServiceExistsReturnsOnCall(i int, result1 error) {
	fake.CheckServiceExistsStub = nil
	if fake.checkServiceExistsReturnsOnCall == nil {
		fake.checkServiceExistsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.checkServiceExistsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeMigrator) CreateAndConfigureServiceInstance(planType string, serviceName string) error {
	fake.createAndConfigureServiceInstanceMutex.Lock()
	ret, specificReturn := fake.createAndConfigureServiceInstanceReturnsOnCall[len(fake.createAndConfigureServiceInstanceArgsForCall)]
	fake.createAndConfigureServiceInstanceArgsForCall = append(fake.createAndConfigureServiceInstanceArgsForCall, struct {
		planType    string
		serviceName string
	}{planType, serviceName})
	fake.recordInvocation("CreateAndConfigureServiceInstance", []interface{}{planType, serviceName})
	fake.createAndConfigureServiceInstanceMutex.Unlock()
	if fake.CreateAndConfigureServiceInstanceStub != nil {
		return fake.CreateAndConfigureServiceInstanceStub(planType, serviceName)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.createAndConfigureServiceInstanceReturns.result1
}

func (fake *FakeMigrator) CreateAndConfigureServiceInstanceCallCount() int {
	fake.createAndConfigureServiceInstanceMutex.RLock()
	defer fake.createAndConfigureServiceInstanceMutex.RUnlock()
	return len(fake.createAndConfigureServiceInstanceArgsForCall)
}

func (fake *FakeMigrator) CreateAndConfigureServiceInstanceArgsForCall(i int) (string, string) {
	fake.createAndConfigureServiceInstanceMutex.RLock()
	defer fake.createAndConfigureServiceInstanceMutex.RUnlock()
	return fake.createAndConfigureServiceInstanceArgsForCall[i].planType, fake.createAndConfigureServiceInstanceArgsForCall[i].serviceName
}

func (fake *FakeMigrator) CreateAndConfigureServiceInstanceReturns(result1 error) {
	fake.CreateAndConfigureServiceInstanceStub = nil
	fake.createAndConfigureServiceInstanceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeMigrator) CreateAndConfigureServiceInstanceReturnsOnCall(i int, result1 error) {
	fake.CreateAndConfigureServiceInstanceStub = nil
	if fake.createAndConfigureServiceInstanceReturnsOnCall == nil {
		fake.createAndConfigureServiceInstanceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createAndConfigureServiceInstanceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeMigrator) MigrateData(donorInstanceName string, recipientInstanceName string, cleanup bool) error {
	fake.migrateDataMutex.Lock()
	ret, specificReturn := fake.migrateDataReturnsOnCall[len(fake.migrateDataArgsForCall)]
	fake.migrateDataArgsForCall = append(fake.migrateDataArgsForCall, struct {
		donorInstanceName     string
		recipientInstanceName string
		cleanup               bool
	}{donorInstanceName, recipientInstanceName, cleanup})
	fake.recordInvocation("MigrateData", []interface{}{donorInstanceName, recipientInstanceName, cleanup})
	fake.migrateDataMutex.Unlock()
	if fake.MigrateDataStub != nil {
		return fake.MigrateDataStub(donorInstanceName, recipientInstanceName, cleanup)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.migrateDataReturns.result1
}

func (fake *FakeMigrator) MigrateDataCallCount() int {
	fake.migrateDataMutex.RLock()
	defer fake.migrateDataMutex.RUnlock()
	return len(fake.migrateDataArgsForCall)
}

func (fake *FakeMigrator) MigrateDataArgsForCall(i int) (string, string, bool) {
	fake.migrateDataMutex.RLock()
	defer fake.migrateDataMutex.RUnlock()
	return fake.migrateDataArgsForCall[i].donorInstanceName, fake.migrateDataArgsForCall[i].recipientInstanceName, fake.migrateDataArgsForCall[i].cleanup
}

func (fake *FakeMigrator) MigrateDataReturns(result1 error) {
	fake.MigrateDataStub = nil
	fake.migrateDataReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeMigrator) MigrateDataReturnsOnCall(i int, result1 error) {
	fake.MigrateDataStub = nil
	if fake.migrateDataReturnsOnCall == nil {
		fake.migrateDataReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.migrateDataReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeMigrator) RenameServiceInstances(donorInstanceName string, recipientInstanceName string) error {
	fake.renameServiceInstancesMutex.Lock()
	ret, specificReturn := fake.renameServiceInstancesReturnsOnCall[len(fake.renameServiceInstancesArgsForCall)]
	fake.renameServiceInstancesArgsForCall = append(fake.renameServiceInstancesArgsForCall, struct {
		donorInstanceName     string
		recipientInstanceName string
	}{donorInstanceName, recipientInstanceName})
	fake.recordInvocation("RenameServiceInstances", []interface{}{donorInstanceName, recipientInstanceName})
	fake.renameServiceInstancesMutex.Unlock()
	if fake.RenameServiceInstancesStub != nil {
		return fake.RenameServiceInstancesStub(donorInstanceName, recipientInstanceName)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.renameServiceInstancesReturns.result1
}

func (fake *FakeMigrator) RenameServiceInstancesCallCount() int {
	fake.renameServiceInstancesMutex.RLock()
	defer fake.renameServiceInstancesMutex.RUnlock()
	return len(fake.renameServiceInstancesArgsForCall)
}

func (fake *FakeMigrator) RenameServiceInstancesArgsForCall(i int) (string, string) {
	fake.renameServiceInstancesMutex.RLock()
	defer fake.renameServiceInstancesMutex.RUnlock()
	return fake.renameServiceInstancesArgsForCall[i].donorInstanceName, fake.renameServiceInstancesArgsForCall[i].recipientInstanceName
}

func (fake *FakeMigrator) RenameServiceInstancesReturns(result1 error) {
	fake.RenameServiceInstancesStub = nil
	fake.renameServiceInstancesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeMigrator) RenameServiceInstancesReturnsOnCall(i int, result1 error) {
	fake.RenameServiceInstancesStub = nil
	if fake.renameServiceInstancesReturnsOnCall == nil {
		fake.renameServiceInstancesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renameServiceInstancesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeMigrator) CleanupOnError(recipientInstanceName string) error {
	fake.cleanupOnErrorMutex.Lock()
	ret, specificReturn := fake.cleanupOnErrorReturnsOnCall[len(fake.cleanupOnErrorArgsForCall)]
	fake.cleanupOnErrorArgsForCall = append(fake.cleanupOnErrorArgsForCall, struct {
		recipientInstanceName string
	}{recipientInstanceName})
	fake.recordInvocation("CleanupOnError", []interface{}{recipientInstanceName})
	fake.cleanupOnErrorMutex.Unlock()
	if fake.CleanupOnErrorStub != nil {
		return fake.CleanupOnErrorStub(recipientInstanceName)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.cleanupOnErrorReturns.result1
}

func (fake *FakeMigrator) CleanupOnErrorCallCount() int {
	fake.cleanupOnErrorMutex.RLock()
	defer fake.cleanupOnErrorMutex.RUnlock()
	return len(fake.cleanupOnErrorArgsForCall)
}

func (fake *FakeMigrator) CleanupOnErrorArgsForCall(i int) string {
	fake.cleanupOnErrorMutex.RLock()
	defer fake.cleanupOnErrorMutex.RUnlock()
	return fake.cleanupOnErrorArgsForCall[i].recipientInstanceName
}

func (fake *FakeMigrator) CleanupOnErrorReturns(result1 error) {
	fake.CleanupOnErrorStub = nil
	fake.cleanupOnErrorReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeMigrator) CleanupOnErrorReturnsOnCall(i int, result1 error) {
	fake.CleanupOnErrorStub = nil
	if fake.cleanupOnErrorReturnsOnCall == nil {
		fake.cleanupOnErrorReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cleanupOnErrorReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeMigrator) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.checkServiceExistsMutex.RLock()
	defer fake.checkServiceExistsMutex.RUnlock()
	fake.createAndConfigureServiceInstanceMutex.RLock()
	defer fake.createAndConfigureServiceInstanceMutex.RUnlock()
	fake.migrateDataMutex.RLock()
	defer fake.migrateDataMutex.RUnlock()
	fake.renameServiceInstancesMutex.RLock()
	defer fake.renameServiceInstancesMutex.RUnlock()
	fake.cleanupOnErrorMutex.RLock()
	defer fake.cleanupOnErrorMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeMigrator) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ plugin.Migrator = new(FakeMigrator)
